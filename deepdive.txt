16장
내부 슬롯과 내부 메서드 
    내부 슬롯과 내부 메서드 ->엔진의 구현 알고리즘을 설명하기 위해 이크마스킈립트 사양에서 사용하는 의사프로퍼티와 의사메서드 [[]] 이거
    내부 슬롯과 내부 메서드는 자바스크립트 엔진의 내부로직 이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메서드 에 직접적으로 접근하거나
    호출할 수 있는 방법을 제공하지 않음 단 일부는 가능

객체 변경 방지
    객체는 변경 가능한 값이므로 재할당 엇이 직저 변경할 수 있다.
    객체 확장금지 
    - object.prerventExtensions 메서드는 객체의 확장을 금지한다 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지.
    객체 밀봉 
    - object.seal 매서드는 객체를 밀봉한다 즉, 밀봉ㄷ딘 객체는 읽기와 쓰기만 가능.
    객체 동결
    - object.freeze 메서드는 객체를 동결한다 즉, 동결된 객체는 읽기만 가능하다.

17장
생성자 함수에 의한 객체 생성 
    생성자의 함수란 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수
    new 연산자와 함께 호풀하면 해당 함수는 생성자 함수로 동작한다
    - this
    함수 호출 방식               this가 가리키는 값
    
    일반 함수 호출                전역객체
    메서드 호출                  메서드를 호출한 객체 (마침표 앞의 객체)
    생성자 함수 호출              생성자 함수가 생성할 인스턴스

    인스턴스 생성과 this바인딩 // 바인딩이란  => 식별자와 값을 연결하는 과정 
    - 암묵적으로 빈 객체가 생성
    인스턴스의 초기화 
    - 생성자 함수에 기술되어 있는 코드가 한줄씩 실행되어 this에 바인딩 되어 있는 인스턴스를 초기화한다.
    인스턴스 반환
    - 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인된 this가 암묵적으로 반환한다.
    -생성자 함수 내부에서 return문읠 반드시 생략

    함수는 객체이지만 일반객체와는 다르다. 일반객체는 호출 할 수 없지만 함수는 호출할 수 있다.
    함수가 일반함수로서 호출되면 함수 객체의 내부 메서드 [[call]]이 호출이 되고,
    new 연산자와 함께 생성자 함수로서 호출되면 내부메서드 [[Construct]]가 호출된다.

    constructor 와 non-constructor의 구분
    constructor 함수 선언문, 함수표현식, 클래스
    non-constructor 메서드,화살표함수

    new 연산자

18장
함수와 일급객체
    일급객체란?
    무명의 리터럴로 생성할 수 있다. 즉 ,런타임 생성이 가능
    변수나 자료구조(=객체,배열)에 저장할 수 있다
    함수의 매개변수에 전달할 수 있다
    함수의 반환값으로 사용할 수 있다
    일반객체는 호출할 수 없지만 함수객체는 호출할 수 있다.

    함수객체의 프로퍼티                                                유사배열 객체란? length프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체
    - arguments 프로퍼티 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회가능한 유사배열객체이며,
    함수 내부에서 지역변수 처럼 사용된다.
    - 선언 된 매개변수의 개수보다 인수를 적게 전달한 경우(multiply(),multiply(1)) 인수가 전달되지 않은 매개변수는 undefined로 초기화된 상태를 유지
            매개변수의 객수보다 인수를 많이 전달한 경우(multiply(1,2,3)) 초과된 인수는 모두 무시
    - arguments객체는 매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할때 유용하다

    length 프로퍼티
    - 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다
    - arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고,
      함수 객체의 length 프로터티는 매개변수의 개수를 가리킨다.
    
    name 프로퍼티
    - 함수의 이름을 나타낸다. 
    - 함수 객체를 가리키는 식별자로 호출

19장
프로토타입
    객체지향 프로그래밍? -> 필요한 속성만 간추려 내어 표현하는 것 = 추상화
    - 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러개의 독립적 단위, 
      즉, 객체의 집합으로 프로그래밍을 표현하려는 프로그래밍 패러다임
    - 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조라 하며, 
      객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현
    - 객체는 상태 데이터와 동작을 하나의 논리적인 단위로 묶ㅇ느 복합적인 자료구조

    상속과 프로토타입
    - 어떤 객체의 프로퍼티 또는 메서드를 다른 객쳋가 상속받아 그대로 사용할 수 있는 것을 말한다

    프로토타입 객체
    - 프로토 타입객체 (=프로토타입) 어떤 객체의 상위(부모) 객체의 역할을 하는 객체 
    - 모든 프로토 타입은 생성자 함수와 연결되어 있다

    __proto__ 접근자 프로퍼티
    - __proto__는 접근자 프로퍼티다
    - __proto__ 접근자 프로퍼티는 상속을 통해 사용된다
    - __proto__ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유
      상호참조에 의해 프로토타임 체인이 생성되는 것을 방지
    - __proto__ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다

    함수객체의 prototype 프로퍼티
    - 함수객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토 타입을 가리킨다

    프로토타입의 constructor 프로퍼티와 생성자함수
    - constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스르 생성한 생성자 함수이다.
    - 프로토타입돠 생성자함수는 단독으로 존재할 수 없고, 언제나 쌍으로 존재한다. 
    - 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
    - 생성자 함수로서 호출할 수 있는 함수, 즉 constructor은 함수 정의가 평가되어 객체함수를 생성하는 시점에 프로토타임도 더불어 생성된다
    - 생성자 함수에 의해 새애성되는 객체의 프로토 타입은 생성자 함수의 prototype  프로퍼티에 바인딩 되어있는 객체다
    - 프로토타입은 객체다. 따라서 일반 객체와 같이 프로토타입에서도 프로퍼티를 삭제/추가 할 수 있다.
      삭제/ 추가된 프로퍼티는 프로토타입 체인에 즉각 반영된다.
    
    프로토타입 체인
    - 프로토타입 체인은 상속된 프로퍼티 검색을 위한 매커니즘
      스코프 체인은 식별자 검색을 위한 매커니즘
    - 내부슬롯의 참조를 따라 자신의 부모 역할으 하는 프로토타입의 프로퍼티를 순차적으로 검색한다
      [[prototype]] 내부슬롯의 값은 null
    - 스코프 체인과 프로토타입 체인은 서로 연관없는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 검색하는데에 사용된다.

    instanceo 연산자
    - 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인상에 존재하는지 확인한다.
    
    object.create 메서드
    - new 연산자가 없어도 객체를 생성
    - 프로토타입을 지정하면서 객체를 생성
    - 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다

    정적 프로퍼티/메서드
    - 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스 참조/호출할 수 없다.
    - 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메서드가 아니므로 인스턴스로 접근 불가

    프로퍼티 존재확인
    - in 연산자 사용 => key in object

    프로퍼티 열거
    - for ... in 문 => for (변수선언문 in 객체)
     객체의 모든 프로퍼티를(프로퍼티 개수만큼) 순회하며 열거하려면 사용 
    - 객체의 프로토타입 체인상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트의 값이 true인 프로퍼티를 순회하며 열거한다
    - for ... in 문은 프로퍼티를 열거할때 순서를 보장하지 않는다.(하지만 대부분 모던 브라우저는 순서를 보장)

20장
strict mode
    - 엄격모드, 암묵적 전역 => 선언하지 않은 변수를 참조하면 에러발생
    - 전역에 scrict mode를 적용하는것은 피하자
    - 함수단위로 scrict mode를 적용하는 것도 피하자

21장
빌트인 객체
    - 표준 빌트인 객체 : string, Number, Boolean, Fucntion, Array, Data
    - 표준 빌트인 객체는 인스턴스 없이도 호출이 가능한 빑인 정적 메서드를 제공한다
    
    원시값과 래퍼 객체
    - 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체

    전역객체 
    - 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체다.
    
    빌트인 전역 함수
    - eval 자바스크립트 코드를 나타내는 문자열을 인수로 받는다 
    - eval 함수는 기존의 스코프를 런타임에 동적으로 수정한다.
    - isFinit 전달받은 인수가 정상적인 유한수 인지 검사하여 t, 무한수는 f로 반환(NaN은 f/ null은 숫자라 tttt)
    - isNaN 전달받은 인수가 NaN인지 검사하여 불리언타입을 반환
    - parseFloat  전달받은 문자열 인수가 부동 소수점 숫자, 즉 실수로 해석해서 반환
    - parseInt  전달받은 인수를 문자열, 문자열이 아니면 문자열로 변환한 다음 정수로 해석해서 반환

22장
this
  - 자신이 속한 객체를 가리키는 식별자
  - this는 자신이 속한 객체 또는 자신이 생성할 인스턴스르 가리키는 자기 참조 변수다.
  - this 바인딩은 this와 this가 가리킬 객체를 바인딩하는건 -> 바인딩? = 식별자와 값을 연결하는 과정

  함수 호출 방식과 this 바인딩
  1.일반함수 호출
  - 기본적으로 this에는 전역 객체가 바인딩 된다
  2.메서드 호출
  - 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다는 것
  3.생성자함수 호출
  - 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다
  4.Fucntion.prototype.apply/call/bind 메서드에 의한 간접호출
  - this로 사용할 객체와 이수 리스트를 인수로 전달받아 함수로 호출한다
    apply 메서드 - 호출할 함수의 인수를 배열로 묶어 전달한다
    call 메서드 - 홏출할 함수의 인수르 쉼표로 구분한 리스트 형식으로 전달한다
    Fucntion.prototype - apply,call 메서드와 달리 함수를 호출하지 않고, 
        첫번 째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 배롭게 생성 반환한다
    bind 메서드는 메서드의 this와 메서드 내부의 중첩함수 또는 콜백함수의 this가 불일치하는 문제를 해결할때 사용

23장
실행 컨텍스트
  자바스크립트의 동작원리를 담고있는 핵심 개념이다.

  소스코드타입
  - 소스코드타입을 4가지로 구분한다.
  전역 코드 | 전역에 존재하는 소스코드를 말한다. 전역에 정의된 함수,클래스등의 내부코드에는 포함되지 않는다.
  함수 코드 | 함수 내부에 존재하는 소스코드를 말한다. 함수내부의 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다
  eval코드 | 빌트인 전역 함수인 eval 함수에 인수롤 전달되어 실행되는 소스코드를 말한다.
  모듈 코드 | 모듈 내부의 조내하는 소스코드를 말한다. 모듈내부의 함수, 클래스 등의 내부 코드는 포함 되지 않는다

  소스코드의 평과와 실행
  자바스크립트 엔진은 소스코드를 2개의 과정 즉, '소스코드의 평과'와 '소스코드의 실행'과정으로 나뉜다.
  
  실행 컨텍스트의 역할
  1. 
  전역 코드 평가 - 평가과정을 거치며 전역코드를 실행하기 위한 준비를 한다. 소스평가과정에서는 선언문만 먼저 실행한다. 따라서 전역코드의 
                변수 선언문과 함수 선언문이 먼저 실행되고, 그 결과 생성된 전역변수와 전역함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다.
                이떄, var(const,let)키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.
  전역 코드 실행 - 평과 과정이 끝나면 런타임이 시작되어 전여고드가 순차적으로 실행된다. 이때, 전역 변수의 값이 할당 되고 함수가 호출된다.
                함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다
  2.
  함수 코드 평가 - 매개 변수와 지역변수 선언문이 먼저 실행되고, 그 결과 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록
                또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역스코프에 등록되고 this바인딩도 결정된다.
  함수 코드 실행 - 런타임이 시작되어 함수코드가 순차적으로 실행된다.매개 변수와 지역 변수에 값이 할당되고 consol.log 메서드가 호출된다
  
  ====>  이처럼 실행 콘텍스트는  소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

  실행 컨텍스트의 스택 
  1. 전역코드의 평가와 실행
  2. foo 함수 코드의 평가와 실행
  3. bar 함수 코드의 평과와 실행
  4. foo 함수 코드로 복귀
  5. 전역코드로 복귀 
  실행 컨텍스트 스택은 실행 순서를 관리한다

  렉시컬 환경 
  - 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조 실행 컨텍스트를 구성하는 컴포넌트다.
  - 스코브를 구분하여 식별자를 등록하고 관리하는 저장소 역할을하는 렉시컬 스코프의 실체다.
  
  살행 컨텍스트의 생성과 식별자의 검색과정
  1. 전역객체생성
  2. 전역 코드평가    
        전역 실행 컨텍스트 생성 -> 비어있는 전역 실행 컨텍스트를 생성하여 스택에 푸시
        전역 렉시컬 환경 생성  -> 전역 환경 레코드 생성 , 객체 환경 레코드 생성, 선언적 환경 레코드 생성 
        this바인딩   -> 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩 된다
        외부 렉시컬 환경에 대한 참조 결정 -> 현재 평가중이 소스코드를 포함하는 외부 소스코드를 렉시컬 환경 스코프 체인을 구현 

24장
클로저 
  렉시컬스코프
  - 자바스크립트 엔진은 함수를 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위스코프를 결정한다.
  - 렉시컬환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조 값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는
    시점에 함수가 정의된 환경(위치) 의해 결정된다.
  함수객체의 내부슬롯
  - 함수는 자신의 내부슬롯[[Environment]]에 자신이 정의 된 환경, 즉 상위 스코프의 참조를 저장한다
  클로저와 렉시컬 환경
  - 외부 함수보다 중첩함수가 더 오래 유지되는 경우 중첩함수는 이미 생명 주기가 종료환 외부함수의 변수를 참조할 수있다 = 클로저  
  클로저의 활용
  - 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용
  캡슐화와 정보 은닉
  - 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
    캡슐화는 객체의 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는 이를 정보 은닉 이라고 한다.
    정보은닉은 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 
    객체의 상태가 변형되는것을 방지해 정보를 보호하고, 객체간의 상호의존성 즉, 결합도를 낮추는효과가 있다.
 
 25
 클래스
  클래스 프로토타입의 문법적 설탕인가
  클래스 정의
    클래스 선언문 => class Person {}
    익명 클래스 표현식 => const Person = class{}; 
    기명 클래스 표현식 => const Person = class Myclass {};
    - 무명의 리터럴로 생성하 수 있다.즉, 런타임에 생성이 가능하다
    - 변수나 자료구조 (객체, 배열 등)에 저장할 수 있다.
    - 함수의 매개변수에게 전달할 수 있다.
    - 함수의 반환값으로 사용할 수 있다.
    클래스는 함수다. 따라서 클래스는 값처럼 사용할 수 있는 일급객체이다. 
  
  클래스 호이스팅

  인스턴스생성
  클래스는 생성자 함수이며, new 연산자와 함께 호출되어 인스턴스를 생성한다.

  메서드
  클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다. 클래스 몸체에서 정의할 수 있는 메서드는 
  constructor(생성자), 프로토타입 메서드, 정적 메서드의 세가지가 있다.
    - constructor은 인스턴스를 생성하고 초기화하기 위한 특수한 메서드 이다.constructor은 이름을 변경할 수 없다
    - constructor 클래스 내에 최대 한개만 존재할 수 있다.
    - constructor를 생략하면 클래스에 빈 constructor가 암묵적으로 정의되며, 그의 의해 빈객체를 생성한다.
    정적메서드
    - 클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드 (클래스 메서드)가 된다.
    - 정적 메서드는 프로토타입 메서드처럼 인스턴스로 호출하지 않고 클래스로 호출한다.
    정적메서드와 프로토타입 메서드의 차이
    1. 정적메서드와 프로토타입메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
    2. 정적메서드는 클래스로 호출하고 프로토타입메서드는 인스턴스로 호출한다.
    3. 정적메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입메서드는 인스턴스 프로퍼티를 참조할 수 있다.
    클래스에서 정의한 메서드의 특징
    1. funcntion 키워드를 생략한 메서드 축약 표현을 사용한다.
    2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요없다
    3. 암묵적으로 strict mode로 실행된다.
    4. for..in문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며
        불리언 값을 갖는 프로퍼티 어트리뷰트 값이 [[Enumerable]]의 값이 false 이다
    5. 내부 메서드[[Construct]]를 갖지 않는 non-constructor이다. 따라서 new 연산자와 함꼐 호출할 수 없다

  클래스의 인스턴스 생성과정
  1. 인스턴스 생성과 this 바인딩
  2. 인스턴스 초기화
  3. 인스턴스 반환
  
  프로퍼티
   인스턴스 프로퍼티 -> constructor 내부에서 정의해야한다 
   접근자 프로퍼티 -> 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자함수 구성되어있다
                  getter : 인스턴스 프로퍼티에 접근할 때마다 프로퍼티의 값을 조작하거나 별도의 행위가 필요할 때 사용
                           (메서드 이름 앞에 get 키워드를 사용해 정의한다)
                  setter : 인스턴스 프로퍼티에 값을 할당할 때마다 프로퍼티의 값을 조작하거나 별도의 행위가 필요할 때 사용
                           (메서드 이름 앞에 set 키워드를 사용해 정의한다)

  상속에 의한 클래스 확장
  - 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의
  
   



   






                      






    